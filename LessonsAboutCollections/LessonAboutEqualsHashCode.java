package LessonsAboutCollections;
/*
 * Есть два метода для сравнивания обьектов, это: 
 * equals();
 * hashCode();
 * Они определены в родительском для всех классе Object. И эти методы принято переопределять.(как и метод toString();)
 * 
 * equals(); - более медленный и точный.
 * hashCode(); - быстрый, но в редких случаях может быть не точным.
 * 
 * hashCode();
 * Хеширование - это когда входные данные превращаются/конвертируються в число. А числа сравнивать легче чем, те самые данные.
 * Этим и занимаеться hashCode();, он превращает заданный обьект в число для дальнейшего сравнения оператором ==.
 * Но метод hashCode(); имеет тип int, и потому его набор чисел ограничен. А вот количество обьектов не ограниченно
 * случаи когда числа у двух обьектов одинаковые называються - коллизией.
 * В случаи колизии нужен метод equals(); более медленный, но точный.
 * 
 * В целом есть множества способов решений коллизий.
 * При переопределинии hashCode(), стоит учитывать что он должен быть быстрым и стараться сделать так что б получать как можно меньше коллизий.
 * 
 * equals();
 * В отличии от hashCode();, метод equals(); сравнивает не числа обьектов. 
 * А сами обьекты, со всеми их полями/переменными, что занимает время.
 * 
 * Все эти методы стоит переопределять, ведь если этого не сделать, они будут сравнивать ссылки на обьекты.
 * И в ситуации когда наши обьекты выглядят вот так:
 * 		Demons demon = new Demons(4, "Nozu");
 * 		Demons demon1 = new Demons(4, "Nozu");
 * Выдадут/вернут результат false. Но ведь мы видим что наши обьекты ОДИНАКОВЫ.
 * Для избежания неприятностей, эти методы стоит переопределить в классе этих обьектов.
 * 
 * Существует "контракт" между hashCode(); и equals(); по которому стоит их переопределять:
 * 1) Для одного и того же объекта, хеш-код всегда будет одинаковым.
 * 2) Если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот).
 * 3) Если хеш-коды равны, то входные объекты не всегда равны.
 * 4) Если хеш-коды разные, то и объекты гарантированно будут разные.
 * 
 * Ну или более просто:
 * 1) У двух проверяемых обьектов вызываем hashCode()
 * если два обьекта разные = тогда и хеши у них разные
 * 2) Если хеши одинаковые = тогда и обьекты одинаковые
 * НО возможна колизия, перепроверяем equals()
 * 3) equals() - даёт точный ответ.
 * 
 * Для того что б не писать каждый раз новый hashCode(); и equals();, можно быстро сгенерировать их в IDE:
 * 1) Сочетанием клавиш alt+shift+s -> выбрать генерацию в окошке.
 * 2) ПКМ по классу -> source -> выбрать генерацию в окошке.
 * 
 * Многие классы например колекции уже имют эти переопределнные методы.
 * Что позволяет им добиваться уникальности в Set и Map колециях
 * 	
 */
public class LessonAboutEqualsHashCode {

	public static void main(String [] args) {
		Demons demon = new Demons(4, "Nozu");
		Demons demon1 = new Demons(4, "Nozu");
		
		Object o = new Object();
		o.hashCode();
		System.out.println(o.hashCode()==o.hashCode());
		
		System.out.println(demon==demon1);
		System.out.println(demon.equals(demon1));
		System.out.println(demon.hashCode()==demon1.hashCode());
		
		
	}
}
