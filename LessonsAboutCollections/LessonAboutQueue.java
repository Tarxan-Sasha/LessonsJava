package LessonsAboutCollections;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
/*
 * Queue - это интерфейс реализующий такую структуру данных как очередь.
 * Которая работает по принципу FIFO(first in, first out) - первый зашел первый вышел.
 * Это значит что элемент который был добавлен первым, первым же обрабатываеться и удаляется.
 * Так же Queue добавляет новые методы, которые уже имеют свои аналоги.
 * Разница лишь в том что одни возвращяют какое то значение, а другие возвращают исключение.
 * Методы:
 * 1)Добавление
 * 	add() - Добавляет элемент в конец очереди, в случае если добавить не может возвращает ИСКЛЮЧЕНИЕ
 * 	offer() - Добавляет элемент в конец очереди, в случае если добавить не может возвращает FALSE
 * 2)Удаление
 * 	remove() - Возвращает элемент и удаляет его. Если нет элементов, возвращает ИСКЛЮЧЕНИЕ
 * 	poll() - Возвращает элемент и удаляет его. Если нет элементов, возвращает NULL
 * 3)Получение
 * 	element() - Возвращает элемент НЕ удаляя его. Если нет элементов, возвращает ИСКЛЮЧЕНИЕ
 * 	peek() - Возвращает элемент НЕ удаляя его. Если нет элементовб возвращает NULL
 * 
 * PriorityQueue - Это класс который реализует интерфейс Queue. 
 * PriorityQueue сортирует очередь по приоритету, где все элементы добавляються, обрабатываются и удаляються по их приоритетности.
 * Приоритетность определяеться с помощью "Естественного порядка" (Для цифр это от меньшого к большему, для букв по алфавиту).
 * Если в очередь добавляються элементы нашего класса, тогда для "Естественного порядка" клас должен реализовать Comparable.
 * Или в конструктор PriorityQueue, передать обьект Comparator нашего класса.
 * Храняться они не в приоритетном порядке, но обрабатываються по приоритетности(сортировке)!
 * 
 * Deque - это интерфейс расширяющий Queue, и реализует двуноправленую очередь.
 * Двуноправленая очередь - это очередь которая может работать по принципу FIFO или по принципу LIFO (как стек).
 * LIFO (Last in, first out) - первым зашел последним вышел.
 * Deque имеет дополнительные методы, которые дают возможность добавлять, удалять, получать элементы из начала и конца очереди.
 * Методы:
 * 1)Добавления
 * 	addFirst/addLast - добавляет в начало или в конец очереди. В случае если добавить не может возвращает ИСКЛЮЧЕНИЕ
 * 	offerFirst/offerLast - добавляет в начало или в конец очереди. В случае если добавить не может возвращает FALSE
 * 2)Удаления
 * 	removeFirst/removeLast - возвращяет элемент из начала или из конца очереди и удаляет его. Если нет элементов, возвращает ИСКЛЮЧЕНИЕ
 *  pollFirst/pollLast - возвращяет єлемент из начала или из конца очереди и удаляет его. Если нет элементов, возвращает NULL
 * 3)Получения
 * 	getFirst/getLast - получить элемент с начала или с конца НЕ удаляя элемент. Если нет элементов, возвращает ИСКЛЮЧЕНИЕ
 * 	peekFirst/peekLast - получить элемент с начала или с конца НЕ удаляя элемент. Если нет элементов, возвращает NULL
 * 
 * ArrayDeque - класс реализующий интерфейс Deque.
 * ArrayDeque создает двуноправленую очередь, можно также указать размер очереди.
 * 
 */
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.SortedSet;
import java.util.TreeSet;

public class LessonAboutQueue {

	public static void main(String[] args) {
		///////////////////////////////////////////////
		List<Integer> arrayList = new ArrayList<>();
		SortedSet<Integer> treeSet = new TreeSet<>();
		///////////////////////////////////////////////
		Queue<Integer> numbers = new PriorityQueue<>();
		numbers.add(2);//Добавляет в конец, но в случае невозможности вернет исключение
		numbers.offer(4);//Добавляет в конец, но в случае невозможности вернет false
		numbers.add(1);//Добавляет в конец, но в случае невозможности вернет исключение
		numbers.offer(3);//Добавляет в конец, но в случае невозможности вернет false
		System.out.println(numbers);
		System.out.println(numbers.remove());//Возвращает значение и удаляет, в случае невозможности возвращает исключение
		System.out.println(numbers.poll());//Возвращает значение и удаляет, в случае невозможности возвращает null
		System.out.println(numbers.remove());//Возвращает значение и удаляет, в случае невозможности возвращает исключение
		System.out.println(numbers.poll());//Возвращает значение и удаляет, в случае невозможности возвращает null
		
		System.out.println();
		//////////////////////////////////////////////////
		Demons demon1 = new Demons(45,"Jiks");
		Demons demon2 = new Demons(324,"Salah");
		Demons demon3 = new Demons(23,"Kof");
		Demons demon4 = new Demons(7,"Tartla");

		DemonsNameComparator dnc = new DemonsNameComparator();//Создаем обьект Comparator демонов
		//Конструкторы PriorityQueue
		Queue<Demons> demons = new PriorityQueue<>();//Обычный конструктор PriorityQueue, количество элементов по умолчанию 11, все сортируеться по "естественному порядку"(Comparable)
		Queue<Demons> demons1 = new PriorityQueue<>(dnc);//Конструктор куда мы передаем обьект Comparator для сортировки
		Queue<Integer> n = new PriorityQueue<>(2);//констуртор где мы устанавливаем нужный нам размер 2
		Queue<Demons> n1 = new PriorityQueue<>(2, dnc);//констуртор где мы устанавливаем нужный нам размер 2, и передаем обьект Comparator для сортировки
		Queue<Integer> n2 = new PriorityQueue<>(arrayList);//это конструтор где мы передаем в PriorityQueue другую колекцию, считай конвертируем её в PriorityQueue.
		   												   //Типы(generic'ы, то что в <>) должны быть одинаковы
		Queue<Integer> n3 = new PriorityQueue<>(treeSet);//Также можно передать колекцию интерфейса SortedSet
		Queue<Integer> n4 = new PriorityQueue<>(numbers);//Также можно передать колекцию интерфейса PriorityQueue, что єстественно
		
		demons.add(demon1);//Добавляет в конец, но в случае невозможности вернет исключение
		demons.offer(demon3);//Добавляет в конец, но в случае невозможности вернет false
		demons.add(demon2);//Добавляет в конец, но в случае невозможности вернет исключение
		demons.offer(demon4);//Добавляет в конец, но в случае невозможности вернет false

		System.out.println(demons);
		
		System.out.println(demons.remove());//Возвращает значение и удаляет, в случае невозможности возвращает исключение
		System.out.println(demons.poll());//Возвращает значение и удаляет, в случае невозможности возвращает null
		System.out.println(demons.remove());//Возвращает значение и удаляет, в случае невозможности возвращает исключение
		System.out.println(demons.poll());//Возвращает значение и удаляет, в случае невозможности возвращает null
		
		System.out.println();
		///////////////////////////////////////////////////
		//Конструкторы ArrayDeque
		Deque<Integer> numbers1 = new ArrayDeque<>();//Обычный конструктор ArrayDeque, количество элементов по умолчанию 16
		Deque<String> name = new ArrayDeque<>(12);//В этом конструторе мы указываем изначальный размер 12
		Deque<Integer> d = new ArrayDeque<>(arrayList);//это конструтор где мы передаем в ArrayDeque другую колекцию, считай конфертируем её в ArrayDeque.
		   											   //Типы(generic'ы, то что в <>) должны быть одинаковы
		numbers1.add(23);//Добавляет в конец, но в случае невозможности вернет исключение
		numbers1.addFirst(33);//Добавляет в начало, но в случае невозможности вернет исключение
		numbers1.addLast(5);//Добавляет в конец, но в случае невозможности вернет исключение
		numbers1.offerFirst(76);//Добавляет в начало, но в случае невозможности вернет false
		numbers1.offerLast(99);//Добавляет в конец, но в случае невозможности вернет false
		System.out.println(numbers1);
		
		System.out.println(numbers1.removeFirst());//Возвращает значение и удаляет с начала, в случае невозможности возвращает исключение
		System.out.println(numbers1.pollFirst());//Возвращает значение и удаляет с начала, в случае невозможности возвращает null
		System.out.println(numbers1.removeLast());//Возвращает значение и удаляет с конца, в случае невозможности возвращает исключение
		System.out.println(numbers1.pollLast());//Возвращает значение и удаляет с конца, в случае невозможности возвращает null
		
	}

}
