package LessonsAboutStreamAPI;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
/*
 * В Java 8 появился Stream API.
 * (API - это перечень возможностей/способов взаемодействия одной програмы с другой)
 * 
 * Stream API появились что бы облегчить различные манипуляции с даными, например: сортировку, фильтрацию.
 * Самое слово stream(поток) в java перегруженно, и если в Streams IO поток представляет собой даные которые идут с источника в точку назначения.
 * То в отношении Stream API это канал передачи данных из источника, он просто передает данные обратно из источника модифицируя их. 
 * Источником могут быть массивы, колекции и файлы.
 * Stream API не хранит данные в себе он их только изменяет и возвращает.
 * 
 * Для изменения Stream API испоьзует операции(по сути методы), которые деляться на:
 * 1)Промежуточные операции - это опреации которые меняют данные и передают их дальше. Их может быть сколько угодно в потоке.
 * 2)Терминальные - это операции которые отдают/возвращают/выдают данные обратно, они возращают результат всего потока, всех изминений и модификаций.
 * Во всем потоке может быть только ОДНа терминальная операция и то в конце.
 * 
 * После обьявления терминальной операции поток закрываетсья и больше взаемодействовать с ним нельзя, нужно создавать новый.
 * (К слову, Stream API не изменияет сам источник данных, то есть если мы отфильтруем колекцию1 и получим результат,
 * то взяв эту колекцию1 снова за источник она не будет изменена, и можно проводить манипуляции снова)
 * Также только после применения терминальнойоперации произведуться вычисления во всех промежуточных операциях,
 * то есть без конечной/терминальной операции поток производить вычисления не будет. 
 * 
 * Stream API в своих операциях использует лямбду, что сокращает код в разы.
 * 
 * (я где то прочитал)
 * Stream API следует применять если проект большой и там много много всего, но если проект маленький, 
 * тогда можно обходиться и без них что бы код был более читаемый.
 * 
 * Класс Stream<T> являеться параметиризованным то есть у него есть дженерик, в который надо вписать тип источника(колеции масива и т.д.).
 * Для создания потоков можно воспользоваться несколькими способами:
 * 1) У интерфейса Collection есть метод stream(), который создает поток с колекцией в качестве источника.
 * 2) У класса Arrays есть метод stream(array<T>), который создаст поток с масивом в качестве источника. 
 * Но в аргумент єтого метода нужно положить масив.
 * Если нужно создать поток с источником масивом типа int double long, тогда для этого есть специализированые интерфейсы:
 * IntStream - для создания потока из int масива 
 * DoubleStream - для создания потока из double масива.
 * LongStream - для создания потока из long масива.
 * Эти интерфейсы не имеют дженерикапотому им его вписывать не нужно.
 * 3) Можно создать источник прямо в момент создания потока методом of() куда нужно вписать данные одного типа. 
 * 
 */
public class LessonAboutStreamAPI {

	public static void main(String[] args) {
		List<Integer> numbers = new ArrayList<Integer>();
		numbers.add(1);
		numbers.add(2);
		numbers.add(3);
		numbers.add(4);
		numbers.add(5);
		numbers.add(6);
		
		//Варинаты создания потока Stream API
		Stream<Integer> stream = numbers.stream();//Создание потока с источником в виде колекции, вызовом метода stream(). Устанавливаем тип потока, в дженерик, как Integer
		stream.filter(x -> x < 5 ).filter(x -> 2 < x).forEach(System.out::print);//Использование сразу двух промежуточных операций filter()
		
		System.out.println();//Перенос строки
		
		numbers.stream().filter(x -> x >= 3 ).forEach(System.out::print);//Или как вариант можно вызвать поток и сразу операции на обработку, не присваивая поток переменной Stream
		
		System.out.println();//Перенос строки
		
		String arrayNames [] = {"Lesha","Ilyukha","Bobos"};
		Stream<String> streamArrayNames = Arrays.stream(arrayNames);//Создание потока с источником в виде масива, 
																	//вызовом метода stream() у клаcса Arrays с передачей в аргумент нужный нам масив. 
																	//Устанавливаем тип потока, в дженерик, как String
		streamArrayNames.filter(x -> x.length() >= 4).forEach(x -> System.out.print(x+" "));
		
		System.out.println();//Перенос строки
		
		IntStream streamArrayInt = Arrays.stream(new int[] {1,2,3,4});//Создание потока с источником в виде масива, 
																	  //вызовом метода stream() у клаcса Arrays с передачей в аргумент нужный нам масив. 
																	  //Устанавливать тип потока не нужно, этот поток работает только с int массивом
		streamArrayInt.filter(x -> x>2).forEach(x -> System.out.print(x+" "));
		
		System.out.println();//Перенос строки
		
		//////////////////////////////////////////////////
		
		DoubleStream streamArrayDouble = Arrays.stream(new double[] {1.1,2.2,3.3,4.4,5.5});//Создание потока с источником в виде масива, 
		  																				   //вызовом метода stream() у клаcса Arrays с передачей в аргумент нужный нам масив. 
																						   //Устанавливать тип потока не нужно, этот поток работает только с double массивом
		streamArrayDouble.filter(x -> x>1.5).forEach(System.out::println);

		LongStream streamArrayLong = Arrays.stream(new long[] {222222,3333333,444444,5555555});//Создание потока с источником в виде масива, 
		  																					   //вызовом метода stream() у клаcса Arrays с передачей в аргумент нужный нам масив. 
																							   //Устанавливать тип потока не нужно, этот поток работает только с long массивом
		streamArrayLong.filter(x->x>432455).forEach(System.out::println);
		
		////////////////////////////////////////////////////////////////
		
		Stream<String> streamCats = Stream.of("Yusa","Barbara","Nikki");//Создать поток сразу с источником данных, с помощью метода of()
																	    //Устанавливаем тип потока, в дженерик, как String
		streamCats.filter(x -> x.length() >= 6).forEach(System.out::print);
		
	}

}
