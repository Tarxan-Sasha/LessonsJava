package LessonsAboutStreamsIO;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/*
 * Поток/поток данных - это последовательность данных у которой есть источник/начало и есть получатель/конец.
 * Это определение подходит именно для потоков Ввода/Вывода. 
 * Само понятие "поток" в програмировании может обозначать множество различных концепций.
 * Сам поток связан с чем то реальным, например: файлом, сетевым сокетом, консолью и т.д.
 * Потоки решают такие задачи как: чтение и запись в файл, передача информации по сети, ввод и вывод в консоль и т.д.
 * 
 * Основными классами потоков ввода/вывода являються InputStream, OutputStream и Reader с Writer.
 * От них начинаеться ирархия потоков и эти классы являються абстрактными, потому обьектов иметь не могут.
 * Но уже их дочерние классы, реализующие их идеи, обьекты иметь могут.
 * 
 * Потоки деляться по типу данных на символьные и байтовые:
 * 1) Байтовые потоки это InputStream и OutputStream, такие потоки работают с байтами и имеют в себе 8-битную информацию.
 * 2) Символьные потоки это Reader и Writer, такие потоки работают с символами и имеют в себе последовательность 16-битовых символов, то есть буквы/символы.
 * 
 * А также потоки деляться по направлению самого потока на:
 * 1) Ввод(Input) - такие потоки считывают/читают данные, такими потоками являються обьекты классов которые наследуют InputStream и Reader.
 * 2) Вывод(Output) - такие потоки записывают данные, такими потоками являються обьекты классов которые наследуют OutputStream и Writer.
 * --------------------------------------------------------------------------------------------------------------------------------------
 * Потоки нужно закрывать, иначе произойдет потеря ресурсов(например, потеря памяти).
 * Все классы которые создают поток имплементируют интерфейс Closeable, который имеет один метод:
 * 	void close() throws IOException - вызов этого метода закрывает пток освобождая ресурсы. 
 * 	Он так же может выбросить исключение IOException, потому при вызове этого метода его нужно обработать.
 * Для 100% закрытия потока методом close(),его нужно вызывать в блоке finally
 * (Блок finnaly срабатівает при любом расскладе, то есть 100%)
 * 
 * В java7 был добавлен второй, более легкий и упрощенный, способ закрытия потоков, а именно try-with-resources.
 * Этим способом могут пользоваться все классы которые имплементируют интерфейс AutoCloseable.
 * Интерфейс Closeable наследуеться(то есть дочерний) от интерфейса AutoCloseable
 * Что означает что все классы которые имплементируют интерфейс Closeable, так же имплементируют и AutoCloseable, а значит могут использовать способ try-with-resources.
 * try-with-resource записываеться вот так:
 * блок try(Обьект класса который имплементирует AutoCloseable){
 * }
 * Так же можно записывать сразу несколько ресурсов через точку с запятой, и они все будут закрыты:
 * блок try(Обьект класса который имплементирует AutoCloseable; Обьект класса который имплементирует AutoCloseable){
 * }
 * 
 * try-with-resource автоматически закрывает поток освобождая ресурсы. Он сам вызовет метод close() когда поток станет не нужным. 
 * С помощью него не нужно вручную закрывать поток, вписывая метод close() и код становиться проще читать.
 * Но старые программы еще используют старый "ручной" способ закрытия, потому его стоит знать или понимать
 * Но предпочтительней использовать новый способ try-with-resource
 */
public class LessonAboutStreamIO {

	public static void main(String[] args) {
		byte [] b = {32,3,1,22,1};
		int i;
		//Записываем в файл
		FileOutputStream fos = null;
		try {
			fos = new FileOutputStream("src/LessonsAboutStreamsIO/Games.txt");//Поток подключаетсЯ к файлу, если такого файла нет - он его создаст
			fos.write(b);
			//fos.close();
		} catch (IOException e) {
			System.out.println("Exception: "+e.getMessage());
		}
		finally{//Использование старой версии закрытия потока, "ручной"
			try {
				fos.close();
			} catch (IOException e) {//метод close() может выбросить исключение IOException, потому мы его обробатываем
				e.printStackTrace();
			}
		}
		
		//Считываем с файла
		//Использование автоматического закрытия потока с помощью try-with-resource. Мы просто в скобочках вписуем обьект класса имплементируещего AutoCloseable
		try(FileInputStream fis = new FileInputStream("src/LessonsAboutStreamsIO/Games.txt")) {//Поток подключаетсЯ к файлу, если такого файла нет - выдаст исключение
			
			while((i=fis.read()) != -1) {
				System.out.print(i+" ");
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
	}

}
