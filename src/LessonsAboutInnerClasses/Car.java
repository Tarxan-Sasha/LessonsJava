/*
 *	Внутренние классы/вложенные классы это продолжение Инкапсуляции, Абстракций и Наследования.
 *	Они нужны когда, напрмер:
 *	1) У классов слишком тесные отношения и один класс не может логически существовать без другого.
 *	2) Для разделения логики, к примеру класс Car будет иметь очень сложный и громозкий код для реализации
 *	всех функций машины. А создание внутренних/вложенных классов, разделяеют эту логику.
 *	
 *	Есть четыре вида внутрених классов:
 *	1) Обычный внутрений не статический класс\вложенный не статический
 *	2) Статический внутрений класс\Статический вложенный класс
 *	3) Локальный класс
 *	4) Анонимный класс
 *	
 *	В этом примере используеться Обычный внутрений не статический класс\вложенный не статический.
 *
 *	Внутренний класс имеет прочную связь с внешним классом.
 *	Это проявляеться в том что:
 *	1)Внутрений класс имеет доступ ко всем методам и переменным внешнего класса (Даже к private).
 *	2)Мы не можем создать обьект внутренего класса без обьекта внешнего класса
 *	Внутри внешнего класса обьект внутренего класса создаеться как всегда:
 *	Window window = new Window();
 *	Но вне внешнего класса, создать просто обьект внутренего класса не выйдет
 *	нужно воспользоватсья обьектом внешнего класса:
 *	Car.Window window = new Car(false).new Window();
 *	или
 *	Car.Window window1 = car.new Window();
 *
 *	За частую внутренний класс имеет модификатор доступа private, что не позволяет создавать обьекты внутренего класса вне внешнего класса
 *	
 *	Для того что бы обратиться к внутренему классу в внутренем классе, нужно использовать слово this
 *	Для того что бы обратиться к внешнем классу в внутренем классе, нужно использовать ИмяВнешнегоКласса.this, например:
 *	Car.this
 *
 *	Создать обьект внутренего класса в статическом методе внешнего класса нельзя.
 *	
 *	Обычный внутрений класс такой же член внешнего класса как и переменные с методами
 *	К обычному внутренему классу применимы, все эти обычные модификаторы:
 *	final
 *	abstract
 *	public
 *	private
 *	protected
 *	static – но static преобразует его во вложенный статический класс
 *	strictfp
 */
package LessonsAboutInnerClasses;



public class Car {
	
	private boolean newCar;//К этой переменной у внутренего класса есть дсступ, несмотря на то что она private

	
	public Car(boolean newCar) {
		this.newCar=newCar;
	}
	
	public void openWindow() {
		Window window = new Window();
		/* 
		 * Тут мы не пишем\не создаем обьект внешнего класса для создания обьекта внутренего
		 * Car.Window window = new Car(false).new Window();
		 * Потому что, при вызове этого метода уже будет существовать обьект класса Car
		 * 
		 */
		window.openWindow();
		window.cosmetics();
		
	}
	public void closeWindow() {
		Window window = new Window();
		window.closeWindow();
	}

	
	private class Window{//За частую имеют модификатор доступа private, что не позволяет создавать обьекты внутренего класса все внешнего класса 
	
		private String coating = "Toning";
		
		private void cosmetics() {
			System.out.println(this.coating+Car.this);
		}
		
		public void openWindow() {
			if(newCar==true) {
				System.out.println("Окно открываеться автоматически");
			}else {
				System.out.println("Окно открываеться вручную");
			}
		}
		public void closeWindow() {
			if(newCar==true) {
				System.out.println("Окно закрываеться автоматически");
			}else {
				System.out.println("Окно закрываеться вручную");
			}
		}
	}
}
