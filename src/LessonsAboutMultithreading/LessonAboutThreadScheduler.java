package LessonsAboutMultithreading;

/*
 * Планировщик потоков - это специальный механизм который решает когда и какому потоку выполняться, а кому уходить в ожидание.
 * Планировщик выбирает поток для выполнения только из тех потоков которые в состоянии runnable(то есть готовых к запуску).
 * Есть два фактора по которым планировщик решает какой поток будет первым:
 * 1) Приоритет потоков - каждый поток имеет свой приоритет от 1 до 10, по умолчанию 5(у того же main потока 5), 
 * чем больше приоритет потока тем выше шанс у потока быть выбраным планировщиком для получения времени работы.
 * С помощью метода setPriority() можно установить приоритет для потока.
 * 2) Время прибытия - когда у потоков одинаковый приоритет планировщик смотрит на их время прибытия, тот кто пришел первый имеет преимущество.
 * 
 * На основе этих двух факторов есть три алогритма работы планировщика.
 * 1) First Come First Serve Scheduling (FCFS) - первый пришел первый обслужился, этот алгоритм запускает тот поток который пришел первым,
 * этот алгортим нужен на случай если потоки имеют одинаковый приоритет.
 * 2) Time Slicing Sheduling - дело в том что алгоритм сверху не являеться выталкивающим/вытесняющим он может привести к тому что 
 * первый прибывший поток может выполнятсья вечно, а остальные потоки будут голодать.
 * *Голодовка у потока - это когда потоку не достаеться памяти процессора совсем или не достаточно что бы он отработал нормально.
 * Алгоритм Time Slicing Sheduling решает эту проблему, он выделяет отрезки/кванты времени для каждого потока на их работу и взаимодействие с процессором.
 * Условно, каждому по 2 секунды, 1 поток отработал 2 секунды, затем второй 2 секунды, потом снова 1, потом снова 2 и так далее...
 * Но опять таки, как я понял, отрезок времени у потока с большим приоритетом будет больше чем у потока с меньшим приоритетом, и если
 * потоку с меньшим приоритетом выделяемого отрезка времени не достаточно ему будет сложно выполняться, что может привести к голодовке.
 * 3) Preemptive-Priority Scheduling - этот алгоритм добавляет приоритетность потокам, например если вдруг поток который прибыл первым не такой важный 
 * как тот что прибыл третим тогда программа может работать не правильно или вовсе не работать. 
 * Для этого есть этот алгоритм он заставляет планировщик смотреть на приоритеты потоков и 
 * запускать/отдавать предпочтение тому который с наивысшим приоритетом.
 * Если посреди работы приложения добавиться новый поток с наивысшим приоритетом, тогда планировщик может остановить текущий, и запустить новый,
 * или просто подождать отработку текущего и запустить следующим тот что с наивысшим приоритетом.
 * В классе Thread есть константы для приоритетов потоков:
 * Thread.MIN_PRIOPiTY(1), Thread.NORM_PRIORITY(5), Thread.MAX_PRIORITY(10).
 * 
 * Планировщик потоков работает примерно таким образом:
 * Он выставляет отрезки времени для каждого потока, запускает поток с наивысшим приоритетом, если приоритет равный тогда смотрит на время прибытия.
 * Когда у потока заканчиваеться процессорное время, планировщик сохраняет его состояние и переводит в конец очереди по его приоритету.
 * Опять таки переключить поток планировщик может из-за конца отрезка/кванта времени, из-за более выского приоритета другого потока, 
 * а так же из-за определенных методов.
 * 
 * !Java практически нечего не гарантирует когда речь идет о потоках!
 * 1) Нет гарантии что потоки выполнятсья в том порядке в котором они были запущены
 * 2) Нет гарантии что потоки не прервыуться во ввремя выполнения
 * 3) Каждый запуск приложения может быть разный
 * 4) Даже на приоритеты полагаться и выстраивать от них работу приложения не стоит. По идеии планировщик смотрит на приоритетность 
 * когда выбирает следующий поток на выполнение, но это по идеии. То есть...блять...НЕ гарантируеться.
 * 5) Точно можно сказать что потоки выполнятсья
 * 6) А так же точно можно сказать как будет выполняться поток у себя в середине 
 * 
 */

public class LessonAboutThreadScheduler {

	public static void main(String[] args) {
		
		TestFire tf = new TestFire();
		Thread tw = new Thread(new TestWater());
		
		System.out.println(tf);//При выводе потока в квадратных скобочках указано следующее: [Имя, приоритетность, и к какой группе он относиться]
		System.out.println(tw);//При выводе потока в квадратных скобочках указано следующее: [Имя, приоритетность, и к какой группе он относиться]
		
		tf.start();
		tw.start();
		
	}

}

class TestFire extends Thread{
	
	public void run() {
		System.out.println("Fire burns");
	}
}
class TestWater implements Runnable{

	@Override
	public void run() {
		System.out.println("Water flows");
	}
	
}





