package LessonsAboutMultithreading;
/*
 * В многопоточности есть несколько проблем которые могут очень просто появиться из-за неверного проектирования:
 * 1) DeadLock (взаимная блокировка) - это проблема которая возникает когда несколько потоков находяться в ожидании ресурсов занятые друг другом,
 * в такой ситуации потоки не могут нормально выполниться - они заблокированы.
 * Пример:
 * поток(1) требует для своего выполнения обьект из потока(2) и без него работать не может,
 * а поток(2) тоже требует обьект, но уже потока(1), и без него тоже работать не может.
 * В таком случае потоки ждут друг друга, они заблокирвоаны.
 * 
 * Для лучшего понимания что такое DeadLock есть примеры из реальной жизни:
 * "В некоторых штатах Индии нельзя получить землю без фермерской лицензии, но фермерскую лицензию нельзя получить без земли"
 * "Я встаю поздно, потому что поздно ложусь, а ложусь поздно потому что поздно встаю"
 * 
 * Полностью уйти от этой проблемы нельзя, её можно лишь избегать такими способами:
 * 1) Избегать внутренних блокирований: Нужно старатсья избегать внутрених блокирований сразу несколько потоков
 * 2) Избегать необязательных блокирований: Блокировку слудет назначать только важным потокам.
 * 3) Использовать join(): с помощью этого метода можно указать сколько текущему потоку ждать другие потоки, как только время исчерпаеться текущий поток продолжит работу.
 * (или с методом join() текущий поток также продолжит свою роботу когда потоки выполнятся, но речь идет об DeadLock, значит там никто не выполниться)
 * 
 * 2) Race condition (Состояние гонки) - это ошибка возникает когда работа программы или приложения зависит от определенного порядка выполнения.
 * В многопточности практически нечего нельзя гарантировать программы могут работать достаточно безпорядочно из-за чего в программах/приложениях
 * которые завязаны на порядке происходит каша, то есть -  Race condition
 * 
 * Например у нас программа будет генерировать рецепт инчеладоса, мы все акуртано роспишем и каждое действие будут выполнять разные потоки
 * и выйдет как то так 
 * 1) Поток1: Теру сыр 
 * 2) Поток2: Ем инчеладос
 * 3) поток3: Разогреваю печку
 * 4) Поток4: Иду за продуктами на енчеладос
 * 
 * Так же Race condition (Состояние гонки) - это состояние когда два потока записывают в одну переменную, и из-за этого сбиваеться результат самой переменной.
 * Потоки не видят друг друга, они вносят данные в переменную, при этом хаотично, кто то получает устаревшие данные, из-за чего ломаеться все вычисления.
 * Починить это можно с помощью синхронизации.
 * 
 * Не всегда Race condition приводит к DeadLock, но DeadLock всегда происходит в Race condition.
 * 
 */
public class LessonAboutProblemsOfMultithreading {

	public static void main(String[] args) {
		
		//Хуевый пример DeadLock'а потому как там нужна синхронизация видимо...а я её еще не прошел
		
		Thread rp1 = new Thread(new ProblemsTest1());
		Thread rp2 = new Thread(new ProblemsTest2());
		
		rp1.start();
		rp2.start();
		
	}

}

class ProblemsTest1 implements Runnable{
	int n=0;
	
	@Override
	public void run() {
		ProblemsTest2 pt2 = new ProblemsTest2();
		if(pt2.n==1) {
			n=1;
			System.out.println("pt2.n "+pt2.n);
		}
	}
	
}

class ProblemsTest2 implements Runnable{
	int n=0;
	
	@Override
	public void run() {
		ProblemsTest1 pt1 = new ProblemsTest1();
		if(pt1.n==1) {
			n=1;
			System.out.println("pt1.n "+pt1.n);
		}
	}
	
}