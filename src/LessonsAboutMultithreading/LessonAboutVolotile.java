package LessonsAboutMultithreading;
/*
 * Есть такое понятие как атомарность.
 * Атомарность - это когда какое-то действие выполняеться за один квант времени.
 * (Когда действие не атомарно, это значит что для выполнения действия нужно больше чем один квант времени)
 * 
 * Например, инкриментирование(увеличить значение на 1) переменной хоть нам кажеться что это быстрый процес на самом деле он состоит из трех этапов:
 * 1) Получить данные переменной
 * 2) Увеличить на 1
 * 3) Записать данные
 * И кажеться что это быстро, но планировщик потоков переключает потоки несколько сотен раз в секунду и кто то может просто не успеть выполнить задачу в 3 действия.
 * В целом зачастую чтение и запись обычных типов переменных являються атомарными, 
 * но чтение и запись типов long и double всегда НЕ атомарно, 
 * потому как эти типы огромны их чтение и запись проводиться только в два кванта.
 * 
 * Так же есть такое понятие как когерентность кешей.
 * Когерентность кешей - это свойство при котором ядра процессора имеют актуальные значения данных в своих кешах.
 * (При многопоточности потоки распределяються по ядрам процессора)
 * У всех ядер процессора есть свои кеши.
 * Кеш - это маленький, но очень быстрый участок памяти, он быстрее чем оперативная память и в сотни раз быстрее жеского диска.
 * Когда поток(1) получает, например, переменную, он может закешировать её себе в кеш, для быстрого доступа.
 * И теперь когда поток(2) изменит эту переменную и отправит в общую паямть, 
 * то поток(1) может этого не увидеть и продолжать работать со старой версией, потому как она осталась неизменна в его кеше, а новую он с общей памяти он не брал.
 * 
 * Как вариант можно решить эту проблему просто создав для всех ядер один кеш, но тогда по сути этот кеш будет копией общей памяти.
 * Пропадет проблема когерентности, значения у ядер будут одинаковые, но упадет производительность ведь кеш может работать только с одним ядром, остальные ядра стояли бы в очереди.
 * 
 * В целом в современных процессорах когерентность хорошо реализивана, кеши очень часто отправляються на проверку в общую память где получают актуальные данные.
 * Но все равно, шанс подобной проблемы есть, например программа будет запущенна на старом процессоре где когерентность реализована плохо.
 * Ну или при новом процессоре случился сбой или недочет.
 * 
 * А если обьеденить две возможные проблемы то, например, в банке потоки должны увеличить нашу зарплату на 1000:
 * 1)первый поток получил данные увеличил их на 1000, но 1000 записана в типе long и он успел записать лишь половину 500
 * 2)второй поток берет эти изменения и кеширует
 * 3)первый получает время на выполнение и увеичивает еще на 500, что бы было ровно 1000
 * 4)второй поток этого не видит и из своего кеша начисляет нам зарплату которая увеличина на 500. :)
 * 
 * Ключевое слово volatile решает обе эти проблемы.
 * volatile - это клбючевое слово для переменных, которое делает следующее:
 * 1) Действия над этой переменной будут всегда атомарны, независимо от того какой её тип long или int
 * 2) Переменная становиться видима для всех потоков(ядер), ядра не будут кешировать переменную с этим словом
 * Услышал в ролике одном что:
 * volatile упрощает логику синхронизации программы
 * 
 */
public class LessonAboutVolotile {

	public static void main(String[] args) {

		VolatileTest vt = new VolatileTest();
		
		Thread t1 = new Thread(vt);
		Thread t2 = new Thread(vt);
		t1.start();
		t2.start();
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		vt.cancel();
		
	}

}



class VolatileTest implements Runnable{

	private volatile boolean  isCancel = false;//В теории без volatile потоки могут не останвоитсья и еще немного проработать, для тестов можно убрать volatile
	
	public void cancel() {
		this.isCancel = true;
	}
	
	@Override
	public void run() {
		
		while(!(isCancel == true)) {
			System.out.println(Thread.currentThread().getName()+": Hello");
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}

	}
	
}