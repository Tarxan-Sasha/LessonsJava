package LessonsAboutMultithreading;

/*
 * Жизненный цикл потока делиться на несколько состояний.
 * Какие из этих состояний обьязательны для его жизни, какие то включаються в определенных случаях.
 * Состояния потока:
 * 1) New - Это состояние потока когда мы создали обьект, НО мы его еще не запустили. То есть он пока что не поток выполнения.
 * 2) Runnable - Один из двух Active состояний потока, это значит что поток готов к запуску\готов работать, просто его еще не выбрал
 * планировщик потоков, включаеться это состояние после запуска метода start().
 * 3) Running - Второй из двух Active состояний потока переключение между ними двумя это самый частый процесс. Это состояние поток получает
 * после вызова метода start(), и когда планировщик потока выделяет ему время и процессор. Это состояние означает что поток выполняеться.
 * Когда один поток Running другие активные потоки имеют состояние Runnable. Как только отрезок времени для потока заканчиваетсья 
 * он добровольно передает, незнаю как написать, мощь процессора другому потоку.
 * 
 * Когда поток не выполняеться, но при этом он не мертв. Он может иметь состояние Blocked, Waiting, Timed waiting:
 * 4) Blocked - Поток заблокирован потому что его задача не может выполниться, например, 
 * ресурс который нужен для роботы этого потока занят на данный момент другим потоком. 
 * В этом состоянии поток не потребляет мощность процессора.
 * 5) Waiting - Поток переводитсья в состояние ожидания когда он ждет другой поток не указанное количество времени. 
 * Например метод join() заставит поток ждать окончание выполнения дочернего потока на не указенное время.
 * Так же есть метод wait() который переводит поток в режим ожидания пока другой поток не вызовит notify() или notifyAll().
 * Состояния Blocked и Waiting не потребляют мощность процессора. 
 * Когда условия для их работы выполняються они переходят(или их переводит планирвощик) в состояние Runnable,
 * откуда уже планировщик потоков решает кому запускатсья, а кому нет.
 * 6) Timed waiting - Это состояние включаеться тогда когда поток ждет определенный отрезок времени. Например, 
 * с помощью метода sleep(), можно усыпить/остановить поток на некоторое время, 
 * или в те же join() и wait() можно указать время на которое они будут остановлены.
 * Как только время выйдет, поток перейдет в состояние Runnable.
 * А потом когда планировщик его запустит, поток начнет с того места где остановился в последний раз.
 * 7) Terminated - это означет что поток завершен, и произойти это может по двум причинам:
 * 		1) Это обычное завершение, поток просто выполнил все что нужно и спокойно завершился.
 * 		2) Второй случай это когда случился сбой: вылетело исключение, ошибка сегментации и т.д.
 * В любом из этих двух вариантов поток остаеться не рабочим, другими словами мертвым. 
 * Нет способа возродить его, метод start() приведет к ошибке
 * 
 * Если как то изобразить жизненный цикл потока то он такой:
 * New -> Runnable -> Running -> Terminated
 * (Но между Runnable -> Running может быть переход из Running в один из этих Blocked/Waiting/Timed waiting, а затем обратно в Runnable) 
 * (Но лучше показать картинку) 
 * 
 * В java есть перчисление/Enum всех состояний потоков, и можно получить это состояние потока вызвав статический метод getState().
 * 
 * 
 */

public class LessonAboutLifeCycle {

	
	public static void main(String[] args) {
		
		Thread t = Thread.currentThread();//Получаем текущий поток
		System.out.println("ThreadMain: "+t.getState());//Получаем статус текущего потока
		Test1 t1 = new Test1();
		System.out.println("Test1 в main: "+t1.getState());//Получаем статус потока
		t1.start();//Запускаем поток
		System.out.println("Test1 в main: "+t1.getState());//Получаем статус потока
		try {
			t1.join(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("ThreadMain: "+t.getState());//Получаем статус потока
	}

}

class Test1 extends Thread{
	
	Thread t = Thread.currentThread();
	public void run(){
		int i=0;
		while(i<=10) {
			if(i==5) {
				System.out.println("Test1 в классе: "+t.getState());//Получаем статус потока
			}
			i++;
		}
		
		
	}
}



























