package LessonsAboutMultithreading;

/* 
 * Бывают ситуации, например, когда потоки пытаються взаимодействовать с одним и тем же общим ресурсом всячески изменяя его,
 * но из-за того что выделенное время у всех разное потоки могут не успевать друг за другом,
 * (формально говоря они и не знают о существовании друг друга)
 * По итогу такой работы выходит каша.
 * Это состояние можно назвать состоянием гонки(Race condition).
 * 
 * Для исправления и нормализации работы потока, есть синхронизация потоков.
 * Синхронизация в многопоточности Java - это механизм который заставляет потоки использовать общий ресурс по очереди.
 * При синхронизации к общему ресурсу имеет доступ только один поток, остальные ждут.
 * Когда поток закончит свое взаимодействие с общим ресурсом, к ресурсу будет допущен следующий поток и так далее.
 * Конечно же программа потеряет скорость, НО результат не будет кашей.
 * 
 * Для реализации синхронизации есть ключевое слово synchronized.
 * synchronized - это ключевое слово которое обозначает что указаный кусок кода является синхронизированным,
 * и доступ к нему может иметь лишь ОДИН поток, остальные ждут.
 * synchronized можно использовать двумя способами:
 * 1) Приписать к методу, тогда метод будет синхронизированым
 * 2) Создать блок кода: synchronized(Object o){    } все что написанно в этом блоке кода являеться синхронизированым.
 * Переменным или классам ключевое слово synchronized приписать нельзя, синхронизировать можно только методы.
 * 
 * Как это происходит:
 * Тут нужно немного отойти от потоков и перейти к обьектам.
 * У каждого обьекта в Java есть свойство Монитор.
 * Это свойство позволяет работать с обьектом ТОЛЬКО одному потоку, другим потокам доступ к обьекту блокируеться.
 * Монитор - это словно флаг/маячок который есть у каждого обьекта в Java, он переключается на блок когда какой-то поток начинает работу с обьектом,
 * и как только поток прекратит работу с обьектом, монитор снова переключитсья на ожидание нового потока что бы принять его и заблокировать доступ для всех остальных.
 * Именно эта особенность Java используеться для синхронизации потоков.
 * 
 * Синхронизация осуществляется по обьекту, 
 * если синхронизировать целый метод, словом synchronized, тогда синхронизация будет осуществляться по монитору текущего обьекта (то есть того который вызовит этот метод),
 * а если указан блок синхронизации, словом synchronized, тогда синхронизация будет осуществлятсья по монитору того оьбекта который будет передан в условие/аргументы блока.
 * 
 * НО синхронизировать также можно и статические методы.
 * Возникает вопрос, если синхронизация осуществляетсья по обьекту, тогда как в этом случае ведь метод статический
 * (static - ключевое слово при котором переменная/метод становятсья достоянием класса, а не обьекта)
 * Дело в том что в таком случае используеться монитор класса, откуда же он у него.
 * В Java есть класс Сlass который представляет классы, и у каждого созданого класса внутри есть обьект Сlass который и представляет этот класс.
 * И именно монитор этого обьекта используеться для синхронизации статических методов
 * 
 * 
 * 
 * 
 */
public class LessonAboutSynchronization {

	
	public static void main(String[] args) {
		Book book = new Book();
		for(int i=0; i<=1; i++) {
			Thread tp = new Thread(new Person(book));
			tp.setName("Thread_"+i);
			tp.start();
		}
	}
}

class Book{
	int x;
}

class Person implements Runnable {
	Book b;	
	Person(Book b){
		this.b=b;
	}
	
	@Override
	public void run() {
		synchronized (b) {//Блок синхронизации, в аргументы ложим обьект и из-за его монитора в этот блок имеет доступ только один поток
			b.x=0;
			for(int i=0; i<=5; i++) {
			System.out.println(Thread.currentThread().getName()+" : x="+b.x);
			b.x++;
		
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			}
		}
		
	}
	
	private synchronized void variant1() {//Синхронизированый метод, тут для синхронизации используеться текущий обьект и из-за его монитора в этот метод имеет доступ только один поток
		//какой-то код
	}
	//Эти два варианта идентичны
	private void variant2() {
		synchronized(this) {//Блок синхронизации, в аргументы ложим обьект( тут это this - по сути текущий обьект) и из-за его монитора в этот блок имеет доступ только один поток
			//какой-то код
		}
	}
	
}