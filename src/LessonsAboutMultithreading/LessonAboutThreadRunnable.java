package LessonsAboutMultithreading;

/*
 * Что бы создать новый поток выполнения нужен обьект класса Thread.
 * Thread - это по сути главный класс потоков, он содержит основные методы для работы с ними, например:
 * 1) start() - запускает поток вызывая его метод run(), один и тот же обьект Thread не может вызвать этот метод дважды, будет ошибка.
 * 2) join() - делает так что бы текущий поток остановился до тех пор пока другой поток(который вызвал метод) не выполнит свою работу.
 * 3) getName() - получить имя потока, оно у него есть по умолчанию
 * 4) setName(String name) - установить имя потока
 * 5) getPriority() - получить приоритет потока
 * 6) setPriority(int number) - установить приоритет потока. В целом приоритет это показатель для процессора к какому потоку дать предпочтения при работе,
 * кто будет первым выполняться. Приоритет выставляеться числом от 1-10. У потока main по умолчанию стоит 5 серединка.
 * 7) isAlive() - проверяет активный ли поток, если да то вернет true, если нет тогда false
 * 8) isInterrupted() - возвращает true если поток был прерван
 * 9) sleep() - усыпляет/приостанавливает/замедляет поток на количество указаных МИЛЛИСЕКУНД
 * 
 * Так же отдельно стоит сказать про еще два метода класса Thread:
 * 1) currentThread() - это статический метод который возвращает текущий поток, например main, в обьект Thread для работы с ним.
 * 2) run() - это метод который нужно переопределить внутри класса потока. По сути все что находиться внутри этого метода это то что будет выполняться в этом потоке.
 * Метод run() это аналог нашего метода main().
 * 
 * Есть два способа создания потока, в обеих нужно переопределять метод run() и в обеих случаях что бы запустить поток нужно вызвать метод start().
 * 1) Способ наследованния от класса Thread.
 * Мы создаем отдельный класс и наследуемся от Thread, после чего мы переопределяем метод run() указывая в нем что должен делать поток.
 * После чего мы просто создаем в нашем main методе обьект нашего класса/нашего потока и запускаем его методом start()
 * 2) Способ реализации/имплементации интерфейса Runnable
 * Мы снова создаем класс и имплементируем интерфейс Runnable. Этот интерфейс являетсья функциональным, он имеет лишь один метод который треубеться реализовать
 * и это метод run(). После чего в методе main() мы создаем обьект нашего класса, а затем обьект класса Thread в конструктор которого ложим только что созданный обьект нашего класса.
 * (Немного запутал, но внизу я показал это)
 * А потом запускаем поток методом start().
 * 
 * В целом 2 способ создания с помощью интерфейса Runnable более предпочтителен, потому Runnable это интерфейси вместе с ним можно имплемнитровать еще кучу других интерфейсов.
 * А если наследоватсья от класса Thread, тогда больше не отчего наследоваться мы не сможем.
 * Если короче то в java нет множественного наследования, потому лучше создавать поток 2 способом с имплементацией интерфейса Runnable
 * 
 * (Из-за того что интерфейс Runnable функциональный то есть имеет только один метод, его можно реализовать с помощью лямбды)
 * 
 * Еще как я понял, по правильному или так обычно делают что бы поток main заканчивался последним, потому есть метод join()
 * с помощью которого можно заставить поток main ждать и не заканчиватсья пока не закончит свою работу поток который вызвал метод join()  
 * 
 */

public class LessonAboutThreadRunnable {

	public static void main(String[] args) {
		Thread tm= Thread.currentThread();//обьект класса Thread принимает main поток, после чего через этот обьект мы можем взаимодействовать с main потоком
		System.out.println("Главный/main поток: "+tm);//Выводим поток на экран
		//При выводе потока в квадратных скобочках указано следующее: [Имя, приоритетность, и к какой группе он относиться]
		
		Test_Thread tt = new Test_Thread();//просто обьект нашего класса наследовашиегося от класса Thread
		tt.start();//вызываем метод старт, который в свою очередь вызывает наш переопределенный метод run() в котором написана вся логика потока
		System.out.println("Поток Test_Thread: "+tt);
		
		Test_Runnable tr = new Test_Runnable();//просто обьект нашего класса с импелментированным интерфейсом Runnable
		//Теперь из-за того что наш класс НЕ наследуеться от класса Thread он НЕ имеет метод start() что б начать свою работу вызвав run()
		//Потому нам нужно создать обьект класса Thread (ведь в нем есть все методы и в частности метод start()) и передать ему наш обьект
		Thread t = new Thread(tr);//Создаем обьект класса Thread, и передаем в него наш обьект
		t.start();//И уже через обьект t мы можем работать с потоком/обьектом tr, например вызвав метод start() который запустит наш поток вызвав там у себя run()
		System.out.println("Поток Test_Runnable: "+t);
		 
	}

}
class Test_Thread extends Thread{
	
	public void run() {
		System.out.println("Thread");
		
	}
}
class Test_Runnable implements Runnable{

	@Override
	public void run() {
		System.out.println("Runnable");
		
	}
	
}
