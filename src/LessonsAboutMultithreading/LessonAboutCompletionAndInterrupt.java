package LessonsAboutMultithreading;

/*
 * Прерывание и завершение потоков.
 * Бывает так что поток должен работать бесконечно, но все равно нужно рассписать как он должен завершатсья.
 * В классе Thread есть три метода stop(), suspend(), resume() они присатонавливают/завершают поток,
 * НО использовать их считаеться устаревшим и пользоваться ними НЕ надо!
 * Потому что поток "убитый" таким оразом во время выполнения операций может оставить обьекты(и не только) в неправильном состоянии.
 * что приведет к ошибкам которые будет тяжело исправить в будущем
 * 
 * Потому есть два способа завершения прерывания потока:
 * 
 * Первый способ это закрытие с помощью своей собственной boolean переменной. 
 * Пока она true(по умолчанию) цикл работает, а отдельным методом мы её переключаем на false.
 * И вызвав этот метод "переключателя" мы останавливаем цикл.
 * 
 * Второй способ это метод interrupt().
 * В классе Thread есть boolean переменная, которая отвечает за то прерван ли поток.
 * Эта переменная называетсья флагом прерывания и она конечно же false изначально.
 * Для работы с ней есть три метода:
 * 1) interrupt() - он "переключает" этот флаг на true. Важно отметить что метод по сути НЕ прерывает поток, 
 * он лишь переключает переменную(флаг прерывания) с false на true. 
 * Метод просто указывает что поток, должен быть прерван. А вот как прерываться и когда это делаеть решает сам поток(програмист). 
 * 
 * 2) isInterrupted() - этот метод проверочный, с помощью него можно проверить какой статус у флага прерывания.
 * Этот метод возвращает boolean значение: true если поток прерван, и false если поток не прерван.
 * 
 * 3) interrupted() - этот метод считай обьеденение двух предыдущих методов. 
 * Он и проверяет возвращая boolean значение: true если поток прерван, и false если поток не прерван.
 * И при этом он сразу после проверки сбрасывает значение флага до false.
 * Этот метод статический из-за чего он проверяет состояние флага у того потока в котором он был вызван,
 * то есть вызвали в потоке main, проверит и сбросит флаг прерывания в потоке main.
 * Потому этот метод вызываетсья только внутри потока которого мы хотим проверить.
 * 
 * Потому поставив в условие цыкла while результат этого флага, можно его контролировать прерывая методом interrupt()
 * 
 * При этом, вызвав метод interrupt() поток может выкинуть исключение InterruptedException 
 * если в этот момент поток использовал следующие методы: sleep() join() класса Thread, wait() класса Object и put() take() класса BlockingQueue.
 * А так же как я понял если будет осуществляться работа потоков ввода вывода (I\O)
 * Причем что это исключение сбрасывает до false флаг прерывания, из-за чего цикл просто продолжиться, 
 * Что бы это решить можно просто или в catch можно вызвать или снова прерывания методом interrupt(), или просто выйти с помощью метода break
 * 
 * По сути, как я понимаю, это такое исключение которое можно решать по разному можно даже создать свое исклчюение и обернуть его, 
 * в интернете много разных способов. Его можно даже не выводить на экран по сути, просто нужно прописать что делать в случае его возникновения.
 * Короче просто обрабатываем любым способом.
 * 
 */

public class LessonAboutCompletionAndInterrupt {

	public static void main(String[] args) {
		
		TestInterruprion ti = new TestInterruprion();
		Thread t = new Thread(ti);
		t.start();// Запускаем поток
		System.out.println("Это до interrupt() (метод main)= "+t.isInterrupted());//Проверяем влажок
		
		try {
			Thread.sleep(500);//Останавливаем поток main на пол секунды
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		t.interrupt();//Прерываем поток

		System.out.println("Это после interrupt() (метод main)= "+t.isInterrupted());//Проверяем состояние флажка
		/*
		 * Вот тут очень интересный момент.(запусти приложение)
		 * При запуске приложения эта строчка (66) вернет false, но почему если это ПОСЛЕ interrupt() и вернуть она ДОЛЖНА true
		 * дело в том что она не успевает)
		 * если убрать "Это после interrupt() (метод main)= "+ тогда она будет возвращать стабильно true
		 * (с этой строкой, есть шанс на true, но очень мелкий)
		 * Как это происходит:
		 * interrupt() на строчке 64, меняет переменную на true, 
		 * и пока 66 строчка обрабатываеться (строка String и к ней добаляетсья boolean, а все что добавляеться к String меняетсья на String)
		 * За это время хоть оно и короткое, второй поток успевает выбросить исключение И СБРОСИТЬ флаг с true обратно на false.
		 * И при этом этот второй поток НЕ успевает вызвать свой interrupt() в catch,
		 * в этот момент заканчивает свою роботу строчка 66 выводя false.
		 * А уже потом в catch срабатывает свой interrupt()
		 * То етсь наврено оно срабатывает в момент когда второй поток 103-105 строчке
		 * 
		 * Но забавно если вписать 107 строчку, тогда шанс получить true должен быть выше, ведь время выполнения становиться немного дольше
		 * 
		 */
		

		
	}
}

class TestInterruprion implements Runnable{

	int i=0;
	
	@Override
	public void run() {
		do{
			System.out.println(++i);
			
			System.out.println("Это до interrupt() = "+Thread.currentThread().isInterrupted());//Проверяем состояние флажка
			
			try {
				Thread.sleep(1000);//Приостанавливаем на секунду
			} catch (InterruptedException e) {
				e.printStackTrace();//Выводим исключение, но можно этого и не делать даже
				
				//System.out.println("Прерываем снова");//Строка для интересного момента)
				
				//Из-за того что это исключение словилось, флажок слетел и он снова false, поток НЕ прерван
				Thread.currentThread().interrupt();//Прерываем снова
				System.out.println("Это после interrupt() в catch = "+Thread.currentThread().isInterrupted());//Снова првоеряем флажок
				
		
			}
			
		}while( !Thread.currentThread().isInterrupted() );//Это условие при котором работает наш do while()
		/*
		 * ! в отношении boolean означает наоборот.
		 * Thread.currentThread().isInterrupted() - возвращает false до метода interrupt(), но с ! вернет true и цикл будет продолжаться.
		 * И уже после того как мы запустили interrupt(), 
		 * Thread.currentThread().isInterrupted() - вернет true, но с ! будет false и цикл останавливаеться
		 * 
		 */
		
	}
	
}







