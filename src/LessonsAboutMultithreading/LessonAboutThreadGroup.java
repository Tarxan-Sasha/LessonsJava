package LessonsAboutMultithreading;

/*
 * Група потоков - это кучка потоков которые обьеденены в одну группу, это позволяет удобно управлять всеми ними в один момент.
 * В общем для этого они и нужны, это удобный встроенный инструмент в java для управления/менеджмента сразу кучки потоков.
 * Мы можем одним методом приостоновить востановить и прервать сразу кучку/группу потоков.
 * (методы suspend() - приостановить, resume() - востанвоить and stop() - остановить, удалены)
 * 
 * В группу потоков можно положить еще одну группу потоков. 
 * Таким образом создаються деревья из различных груп потоков: где в групе потоков есть еще група, а там еще и так далее...
 * В таких деревях все имеют родительскую группу кроме первой основной.
 * 
 * Поток имеет доступ к информации своей группы потоков, но НЕ имеет доступа к информации родительской группы потоков,
 * или просто второй группы потоков в этой группе потоков.
 * Что я имею в виду:
 * [Первая группа потоков 1 [Вторая группа потоков 2]  [Третия группа потоков 3]]
 * 1) Первая группа потоков 1 - это родительская группа потоков, тут есть доступ к информации по всему дереву и к группе 2 и к группе 3.
 * 2) Вторая группа потоков 2 - это группа потоков уже дочерняя от первой, потоки этой группы имеют доступ к информации только своей группы, а именно 2.
 * Ни к информации родительской группы 1 или к обычной группы 3 потоки со второй группы доступа не имеют.
 * 3) Третия группа потоков 3 - все так же как и у второй группы, только тут третия.
 * Доступа нет ни к групе 2 ни к групе 1, доступ ТОЛЬКО к информации своей групы.
 * 
 * Что бы создать группу нужно создать обьект класса ThreadGroup.
 * У этого класса есть методы для работы с групой потоков, вот несколько:
 * 1) activeCount() - вернет int всех активных потоков в Группе
 * 2) activeGroupCount() - вернет int активных груп потоков
 * 3) enumerate() - копирует все активные потоки групы(и под груп) в указанный масив. 
 * Этот метод имеет перегруженые версии где можно, например, указать что б копировались только активные потоки групы БЕЗ потоков из под.груп.
 * А можно указать что б копировались только потоки под.груп, а потоки родительской группы нет.
 * 4) list() - выводит списком всю информацию про потоки в группе на консоль(через out)
 * 
 */
public class LessonAboutThreadGroup {

	public static void main(String[] args) {
		
		ThreadGroup tg1 = new ThreadGroup("FirstGroup");//Первая группа потоков, в конструктор ложим имя для этой новой групы
		ThreadGroup tg2 = new ThreadGroup(tg1,"SecondGroup");//Вторая группа потоков её мы положим в первую, для этого:
															 //Первым элементом кладем имя уже существующей группы в которую мы хотим положить новую группу
															 //Вторым элементом указываем имя этой новой группы
		
		//Потоки которые кладуться в первую группу
		Thread t1 = new Thread(tg1,new GroupThreadTest());//Указываем группу куда кладем, тут это tg1, ну и сам обьект.
		Thread t2= new Thread(tg1,new GroupThreadTest());
		Thread t3 = new Thread(tg1,new GroupThreadTest());
		
		t1.start();
		t2.start();
		t3.start();
		
		//Потоки которые кладуться во вторую группу
		Thread t4 = new Thread(tg2,new GroupThreadTest());//Указываем группу куда кладем, тут это tg2, ну и сам обьект.
		Thread t5 = new Thread(tg2,new GroupThreadTest());
		Thread t6 = new Thread(tg2,new GroupThreadTest());
		
		t4.start();
		t5.start();
		t6.start();
		
		System.out.println("Активных потоков в первой группе "+tg1.activeCount());
		System.out.println("Активных потоков во второй группе "+tg2.activeCount());
		
		tg1.list();//Выводим всю информацию о потоках в группе на єкран
		//Информация будет и по подгруппам поскольку мы вызваем этот метод на родительской группе
		System.out.println("Максимальный приоритет второй группы потоков: "+tg2.getMaxPriority());
		

	}

}
class GroupThreadTest implements Runnable{
	static int number = 0;
	@Override
	public void run() {
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
}