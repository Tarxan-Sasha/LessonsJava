package LessonsAboutMultithreading;

import java.util.concurrent.Semaphore;

/*
 * Семафор - это еще один способ синхронизации, но уже для отдельного ресурса.
 * Семафор открывает и закрывает доступ к ресурсу для определенного количества потоков.
 * Внутри семафора есть счетчик разрешений(талончики на вход:3), каждый раз когда какой-то поток получает доступ к ресурсу он уменьшает счетчик на один,
 * когда этот счетчик пададет до нуля, потоки больше не имеют возможности пользоваться ресурсом.
 * А когда какой-то поток заканчивает работу с ресурсом он увеличивает счетчик на один.(то есть, возвращает талончик:3)
 * 
 * Для реализации семафора в Java есть класс Semaphore, у него есть несколько методов:
 * 1) acquire() - это метод который пропускает потоки к ресурсу и отнимает от счетчика разрешений 1 за каждый пропущенный поток,(отбирает талончик:3)
 * если счетчик разрешений будет равен 0, тогда все потоки после вызова этого метода остановятся и перейдут в режим блокировки пока счетчик не будет больше 0.
 * 2) release() - увеличивает счетчик разрешений на 1(возвращает талончик:3), всякий раз когда поток заканчивает свою работу с ресурсом он ДОЛЖЕН вызвать этот метод,
 * что бы другой поток мог разблокироватсья и тоже приступить к работе.
 * Этот метод стоит вызывать в finnaly{} для того что бы 100% освободить место(что бы точно отдать талончик:3), потому как acquire() способен вызвать исключение
 * и если исключение выскочит тогда поток дропниться не востановив счетчик разрешений(не вернув талончик:3)
 * (finnaly - ключевое слово в связке try catch finally, означает что то что было написанно в его теле 100% выполниться несмотря на выброшенное исключение)
 * 3)availablePermits - метод который возвращает текущий счетчик разрешений, то есть количество талончиков:3
 * 
 * Семафоры отлично подходят когда нужно ограничить доступ к ресурсу, и они отлично компанируються с синхронизацией synchronized
 * 
 */

public class LessonAboutSemaphore {

	public static void main(String[] args) {
		//Конструкторы Semaphore
		Semaphore s1 = new Semaphore(4);//Здесь мы передаем int количество разрешений, у нас их будет 4
		Semaphore s2 = new Semaphore(3, true);//Здесь мы передаем int количество разрешений у нас их будет 3, 
											  //а так же передаем boolean значение которое отвечает за очередность в получении доступа, 
											  //если равен true тогда потоки будут получать доступ в том порядке в котором запрашивали 
		Minerals m = new Minerals();
		for(int i=0; i<=6; i++) {
			Thread tKSM = new Thread(new KSM(s2,m));
			tKSM.start();
		}

	}

}

class Minerals{
	int minerals = 60;
}

class KSM implements Runnable{
	private Semaphore s;
	private Minerals m;
	private int collectedMinerals=0;
	public KSM(Semaphore s, Minerals m) {
		this.s=s;
		this.m=m;
	}
	
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName()+" подьехал к миниралам");
		try {
			s.acquire();//Даёт доступ к ресурсу, если счетчик равен 0, все потоки вызовут этот метод и будут заблокированы
			if(s.availablePermits() == 0) {
				System.out.println("Места у минералов закончились!!! - сообщает "+Thread.currentThread().getName());
			}
			System.out.println(Thread.currentThread().getName()+" собираю миниралы");
			while(collectedMinerals >= 10) {
				m.minerals--;
				collectedMinerals++;
			}
			
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			s.release();//возвращаем один дуступ после работы
		}
		System.out.println(Thread.currentThread().getName()+" собрал миниралы");
	}
	

	
}